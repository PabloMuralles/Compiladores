# Mini C#

Es una implementaci√≥n peque√±a de un compilador para el lenguaje C#

## Tabla de Contenido üöÄ

- [Fase 1](#Fase-1)
     - [Requerimientos](#Requerimientos-)
          - [Objetivo](#objetivo)
          - [Estructura Lexicogr√°fica](#Estructura-Lexicogr√°fica)
          - [Funcionamiento](#funcionamiento-%EF%B8%8F)
- [Fase 2](#fase-2)
     - [Requerimientos](#requerimientos--1)
          - [Gram√°tica Implementada](#gram√°tica-implementada--)
          - [Tabla de An√°lisis](#tabla-de-an√°lisis--)
          - [Manejo de Errores](#manejo-de-errores-)
          - [Ejecutando las pruebas](#ejecutando-las-pruebas-%EF%B8%8F)
 - [Fase 2](#fase-3)
     - [Requerimientos](#requerimientos--1)
           
- [Construido con](#construido-con-%EF%B8%8F)
- [Autores](#autores-%EF%B8%8F)
- [Licencia](#licencia-)
 
 


## Fase 1 

### Requerimientos üìã

#### Objetivo

En el primer proyecto de programaci√≥n, ustedes iniciar√°n su compilador con la aplicaci√≥n
del an√°lisis l√©xico. Para la primera tarea del front-end, crear√°n un esc√°ner para el lenguaje
de programaci√≥n asignado. El esc√°ner ir√° reconociendo los tokens en el orden en que se
leen, hasta el final del archivo. Para cada lenguaje, el esc√°ner determinar√° sus atributos
adecuadamente (estos eventualmente ser√°n utilizados por otros componentes de su
compilador) para que la informaci√≥n sobre cada s√≠mbolo deba estar correctamente impresa. 

#### Estructura Lexicogr√°fica

##### ‚óè Palabras clave (reservadas)

void int double bool string class const interface null this for while foreach if else 
return break New NewArray Console WriteLine 

##### ‚óè Identificadores

Un identificador es una secuencia de letras, d√≠gitos y guiones bajos siempre comenzando
con una letra.

```
Correcto:
cadeba_1
num1
listNum_

Incorrecto:
12num
_cadena
```
#####  ‚óè Case Sensitive

-Distingue entre may√∫sculas y min√∫sculas
```
if es una palabra clave pero IF es un identificador

binky y Binky son dos identificadores distintos. 
```

##### ‚óè Espacios en blanco

El espacio en blanco (es decir, espacios, tabuladores y saltos de l√≠nea) sirve para
separar tokens, pero por lo dem√°s debe ser ignorado. Palabras clave y los
identificadores deben estar separados por espacios en blanco, o por una se√±al de
que no es ni una palabra ni un identificador.

```if ( 23 this se escanea como cuatro tokens, al igual que if(23this```

##### ‚óè Comentarios

-De una lines: inicio con ```//``` y todo lo que siga hasta el final de la linea sera un comentario se permite cualquier simbolo dentro de estos.

-De varias lineas: inicia con ```/*``` y termina con ```*/``` cualquier simbolo se acepta en un comentario sin tomar en cuenta '*/' ya que pone fin al comentario, estos comentarios no se anidan.

##### ‚óè Constantes

-Booleanas: Estas pueden ser ```true``` o ```false```.

-Entero: Puede expresarse en base 10 o base 16 
     -Los de base 10 deben ser una secuencia de digitos de 0-9
     -Los de base 16 deben de empezar con ```0``` seguido de ```x``` o ```X ```    

```
Correcto:
4
50
0487
0xFf217
0XA41E1

Incorrecto:
FF217
5.2
.5
 ```
-Doubles: Es una secuencia de digitos, un punto, segudio de una secuencia de digitos o nada. Tambien despu√©s del puntos puede venir un numero o nada seguido de una notaci√≥n cient√≠fica que puede o no tener el signo del exponente si no lo tiene se asume que es un ``+``

```
Correcto:
58.5
13.
0.15
0.2E2
28.2e-2
48.4e+2

Incorrecto:
.78
.44E15
45.3.15
```

-Strings: Es una secuencia de caracterres dentro de commillas dobles ``""``. Estas no pueden contener ``"`` , una linea nueva, o un caracter nulo. Deben de comenzar y terminar en la misma linea no se permite que comiense en una y termine en otra.

```
Correcto: 
"esto cadena es un string correcta"

Incorrecto:
"esta es una parte de la cadena
esto es otra parte de la cadena

"ser√° que esto
esta bueno jejeje"
```

##### ‚óè Operadores y caracteres de puntuaci√≥n

```
+ - * / % < <= > >= = == != && || ! ; , . [ ] ( ) { } [] () {}
```

#### Funcionamiento ‚öôÔ∏è

Los archivos de salida se guardar√°n en el directorio del proyecto espec√≠ficamente en la siguiente ruta: \bin\Debug\Salida

A continuaci√≥n, un peque√±o video del funcionamiento de la fase 1

[![VIDEO](https://img.youtube.com/vi/1HR2VJ3BnYc/0.jpg)](https://www.youtube.com/watch?v=1HR2VJ3BnYc)

## Fase 2

### Requerimientos üìã

#### Gram√°tica Implementada  üìÉ 

```
S' -> Program
Program -> Decl Program
Program -> Decl 
Decl -> Type ident ;
Decl ->Type ident ( Formals ) StmtBlock
Decl ->void ident ( Formals ) StmtBlock
Decl -> class ident Id Id' { Field‚Äô }
Decl -> interface ident { Prototype‚Äô }
Decl -> const ConstType ident ; 
Type -> int
Type -> double
Type -> bool
Type -> string
Type -> ident
Type -> Type []
ConstType -> int
ConstType -> double
ConstType -> bool
ConstType -> string
Formals -> Type ident , Formals
Formals -> Type ident
Id -> : ident
Id -> Œµ
Id' -> , ident Id'
Id' -> Œµ
Field‚Äô -> Field Field‚Äô
Field‚Äô -> Œµ
Field -> Type ident ;
Field -> Type ident ( Formals ) StmtBlock
Field -> void ident ( Formals ) StmtBlock
Field -> const ConstType ident ;
Prototype‚Äô ->  Prototype Prototype‚Äô
Prototype‚Äô -> Œµ
Prototype -> Type ident ( Formals ) ;
Prototype -> void ident ( Formals ) ;
StmtBlock -> { Declare }
Declare -> VariableDecl Declare
Declare -> ConstDecl Declare
Declare -> Stmt‚Äô Declare
Declare -> Œµ
ConstDecl-> const ConstType ident ;
VariableDecl -> Type ident ;
Stmt‚Äô -> Stmt
Stmt -> Expr ;
Stmt -> ;
Stmt ->  if ( Expr ) Stmt IfStmt
Stmt -> while ( Expr ) Stmt
Stmt -> for ( Expr ; Expr ; Expr ) Stmt
Stmt -> break ;
Stmt -> return Expr ;
Stmt -> Console . WriteLine ( Expr‚Äô ) ;
Stmt -> StmtBlock
Stmt -> ident ( Actuals )
Stmt -> ident . ident ( Actuals )
Actuals -> Expr , Actuals
Actuals -> Expr 
IfStmt -> else Stmt
IfStmt -> Œµ
Expr‚Äô -> Expr , Expr‚Äô
Expr‚Äô -> Expr 
Expr -> ident = ConditionAnd
Expr -> ConditionAnd
ConditionAnd -> Equality ConditionAnd'
ConditionAnd' -> && Equality ConditionAnd'
ConditionAnd' -> Œµ
Equality -> Equality == Relational
Equality -> Relational
Relational -> Relational < Additive
Relational -> Relational <= Additive
Relational -> Additive
Additive -> Additive + Multiplicative
Additive -> Multiplicative
Multiplicative -> Multiplicative * Unary
Multiplicative -> Multiplicative % Unary
Multiplicative -> Unary 
Unary -> - Primary
Unary -> ! Primary 
Unary -> Primary
Primary -> Primary . ident = Expr
Primary -> Primary . ident  
Primary -> Terminal
Terminal -> this
Terminal -> ( Expr )
Terminal -> New ( ident )
Terminal -> intConstant
Terminal -> doubleConstant
Terminal -> boolConstant
Terminal -> stringConstant
Terminal -> null
Terminal -> ident
```


##### Documento con la gram√°tica: [DOC](https://github.com/PabloMuralles/Compiladores/blob/Analizador_sint%C3%A1ctico/Documentacion/Gram%C3%A1tica%20Corregida.pdf)

##### Follows: [DOC](https://github.com/PabloMuralles/Compiladores/blob/Analizador_sint%C3%A1ctico/Documentacion/Follows.pdf)



#### Tabla de An√°lisis  üìú

El analizador es de tipo SLR

##### Documento con la tabla de an√°lisis: [DOC](https://github.com/PabloMuralles/Compiladores/blob/fase3/Documentacion/Tabla%20de%20Analisis.xlsx)

#### Manejo de Errores ‚ùå

El analizar sint√°ctico a la hora de encontrar un error consume el token donde marco error y guarda el error para posteriormente mostrarlo al usuario, todo lo que resta de esa l√≠nea lo ignora y salta de l√≠nea, a la hora de saltar de l√≠nea el an√°lisis sint√°ctico empieza de cero. Si todos los tokens de entrada son consumidos y llega al estado de aceptaci√≥n indicara que el c√≥digo ingresado es correcto de lo contrario mostrara los errores en pantalla.

#### Ejecutando las pruebas ‚öôÔ∏è

El analizador cargar su tabla de an√°lisis y las producciones de la gram√°tica desde archivos de texto que se encuentran en la carpeta Gram√°tica en la soluci√≥n de la aplicaci√≥n por lo tanto para poder realizar pruebas es necesario tener en cuenta que esta carpeta exista con sus archivos para que funcione de la manera correcta.

Ruta de los archivos anteriores: 

Ruta Relativa:

"\Gramatica\Gramatica.txt"

"\Gramatica\Tabla_analisis.txt"

## Fase 3

### Requerimientos üìã
     
#### Objetivo

La tercera fase del proyecto consistir√° en generar la tabla de s√≠mbolos, realizar la asignaci√≥n
de valores a variables y constantes, comprobar los tipos de ciertas expresiones para los
lenguajes que est√°n trabajando

#### Estructura de la Tabla de S√≠mbolos
```
TYPE:class| NAME:Parser| VALUE:NULL|AMBIT:NULL 
TYPE:int| NAME:a1| VALUE:8|AMBIT:Programmain 
TYPE:int| NAME:f1| VALUE:3|AMBIT:Parserf1 
TYPE:int| NAME:a| VALUE:NULL|AMBIT:Parserf1 
TYPE:int| NAME:b| VALUE:NULL|AMBIT:Parserf1 
TYPE:int| NAME:c| VALUE:NULL|AMBIT:Parserf1 
TYPE:int| NAME:p1| VALUE:3|AMBIT:Parserf1 
TYPE:void| NAME:proc1| VALUE:NULL|AMBIT:Parserproc1 
TYPE:double| NAME:y| VALUE:NULL|AMBIT:Parserproc1 
TYPE:class| NAME:Program| VALUE:NULL|AMBIT:NULL 
TYPE:void| NAME:main| VALUE:NULL|AMBIT:Programmain 
TYPE:string| NAME:x| VALUE:NULL|AMBIT:Programmain 
TYPE:double| NAME:m1| VALUE:7.5|AMBIT:Programmain 
TYPE:int| NAME:m3| VALUE:NULL|AMBIT:Programmain 
TYPE:bool| NAME:t| VALUE:NULL|AMBIT:Programmain 
TYPE:string| NAME:mensaje| VALUE: hola   mundo |AMBIT:Programmain 
TYPE:ident| NAME:MyParser| VALUE:NULL|AMBIT:Programmain 
TYPE:int| NAME:m2| VALUE:NULL|AMBIT:Programmain 
TYPE:bool| NAME:p| VALUE:False|AMBIT:Programmain 
TYPE:=| NAME:t| VALUE:NULL|AMBIT:Program 
```
#### Mantenimiento de la S√≠mbolos

La tabla de s√≠mbolos se le da mantenimiento cada vez que se defina una variable, clase, procedimiento o funci√≥n. Se verifica que ya exista y sino existe se agrega a la tabla de s√≠mbolos, tambi√©n cuando se realiza una asignaci√≥n o un return se actualiza el valor del elemento de la tabla de s√≠mbolos al que se le esta asignando.

#### Manejo de Errores ‚ùå

 

## Construido con üõ†Ô∏è

* [.NET](https://dotnet.microsoft.com/download/dotnet-framework/net472) - Framework usado

## Autores ‚úíÔ∏è

**Pablo Muralles**  - Carn√©:1113818

**Santiago Bocel**  - Carn√©:1076818

## Licencia üìÑ

A short and simple permissive license with conditions only requiring preservation of copyright and license notices. Licensed works, modifications, and larger works may be distributed under different terms and without source code. 
see more in [LICENSE](https://github.com/PabloMuralles/Compiladores/blob/master/LICENSE) for more details.
